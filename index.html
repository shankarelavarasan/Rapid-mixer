<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapid AI Assistant</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #4f46e5;
            background-color: rgba(79, 70, 229, 0.1);
        }
        .progress-bar {
            height: 8px;
            background-color: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: #4f46e5;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-indigo-700">Rapid AI Assistant</h1>
            <p class="text-gray-600 mt-2">Powerful AI processing for your files and folders</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Input Section -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">Input</h2>
                
                <!-- Prompt Input -->
                <div class="mb-4">
                    <label for="prompt" class="block text-sm font-medium text-gray-700 mb-1">Prompt</label>
                    <textarea id="prompt" rows="4" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter your prompt here..."></textarea>
                </div>
                
                <!-- Template Selection -->
                <div class="mb-4">
                    <label for="template" class="block text-sm font-medium text-gray-700 mb-1">Template (Optional)</label>
                    <select id="template" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="">No Template</option>
                        <!-- Templates will be loaded dynamically -->
                    </select>
                </div>
                
                <!-- File Upload -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Upload Files</label>
                    <div id="dropZone" class="drop-zone">
                        <p>Drag & drop files here or</p>
                        <input type="file" id="fileInput" multiple class="hidden">
                        <button id="browseButton" class="mt-2 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500">Browse Files</button>
                    </div>
                    <div id="fileList" class="mt-2 text-sm text-gray-600"></div>
                </div>
                
                <!-- Folder Upload -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Upload Folder</label>
                    <div id="folderDropZone" class="drop-zone">
                        <p>Drag & drop a folder here or</p>
                        <input type="file" id="folderInput" webkitdirectory directory multiple class="hidden">
                        <button id="browseFolderButton" class="mt-2 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500">Browse Folders</button>
                    </div>
                    <div id="folderStats" class="mt-2 text-sm text-gray-600"></div>
                </div>
                
                <!-- Options -->
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="outputFormat" class="block text-sm font-medium text-gray-700 mb-1">Output Format</label>
                        <select id="outputFormat" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="text">Text</option>
                            <option value="json">JSON</option>
                            <option value="html">HTML</option>
                            <option value="markdown">Markdown</option>
                        </select>
                    </div>
                    <div>
                        <label for="processingMode" class="block text-sm font-medium text-gray-700 mb-1">Processing Mode</label>
                        <select id="processingMode" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="individual">Individual Files</option>
                            <option value="combined">Combined</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex items-center mb-4">
                    <input type="checkbox" id="saveOutput" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                    <label for="saveOutput" class="ml-2 block text-sm text-gray-700">Save Output</label>
                    <input type="text" id="outputDestination" placeholder="Output directory" class="ml-4 flex-1 px-3 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" value="./output">
                </div>
                
                <div class="flex items-center mb-4">
                    <input type="checkbox" id="asyncProcessing" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                    <label for="asyncProcessing" class="ml-2 block text-sm text-gray-700">Asynchronous Processing (for large folders)</label>
                </div>
                
                <!-- Submit Buttons -->
                <div class="flex gap-4">
                    <button id="submitButton" class="flex-1 py-2 px-4 bg-indigo-600 hover:bg-indigo-700 text-white font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">Process with AI</button>
                    <button id="pushButton" class="py-2 px-4 bg-green-600 hover:bg-green-700 text-white font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-green-500">Push to GitHub</button>
                </div>
            </div>
            
            <!-- Output Section -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">Output</h2>
                
                <!-- Progress Bar (hidden by default) -->
                <div id="progressContainer" class="mb-4 hidden">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Processing Progress</label>
                    <div class="progress-bar">
                        <div id="progressBar" class="progress-bar-fill" style="width: 0%"></div>
                    </div>
                    <p id="progressText" class="text-sm text-gray-600 mt-1">0%</p>
                </div>
                
                <!-- Status Message -->
                <div id="statusMessage" class="mb-4 p-3 bg-gray-100 rounded-md text-gray-700 hidden"></div>
                
                <!-- Response Output -->
                <div id="responseContainer" class="border border-gray-300 rounded-md p-4 h-96 overflow-auto bg-gray-50">
                    <pre id="responseOutput" class="text-gray-800 whitespace-pre-wrap">Results will appear here...</pre>
                </div>
                
                <!-- Action Buttons -->
                <div class="flex justify-between mt-4">
                    <button id="copyButton" class="py-2 px-4 bg-gray-600 hover:bg-gray-700 text-white font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500">Copy to Clipboard</button>
                    <button id="downloadButton" class="py-2 px-4 bg-green-600 hover:bg-green-700 text-white font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-green-500">Download Result</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Socket.io connection
            const socket = io();
            
            // Elements
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const browseButton = document.getElementById('browseButton');
            const fileList = document.getElementById('fileList');
            
            const folderDropZone = document.getElementById('folderDropZone');
            const folderInput = document.getElementById('folderInput');
            const browseFolderButton = document.getElementById('browseFolderButton');
            const folderStats = document.getElementById('folderStats');
            
            const submitButton = document.getElementById('submitButton');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const statusMessage = document.getElementById('statusMessage');
            const responseOutput = document.getElementById('responseOutput');
            const copyButton = document.getElementById('copyButton');
            const downloadButton = document.getElementById('downloadButton');
            
            // Template dropdown
            const templateSelect = document.getElementById('template');
            
            // Load templates
            fetch('/api/templates')
                .then(response => response.json())
                .then(data => {
                    if (data.templates && Array.isArray(data.templates)) {
                        data.templates.forEach(template => {
                            const option = document.createElement('option');
                            option.value = template;
                            option.textContent = template;
                            templateSelect.appendChild(option);
                        });
                    }
                })
                .catch(error => console.error('Error loading templates:', error));
            
            // File upload handling
            browseButton.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', () => {
                updateFileList(fileInput.files);
            });
            
            // Drag and drop for files
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                updateFileList(e.dataTransfer.files);
            });
            
            // Folder upload handling
            browseFolderButton.addEventListener('click', () => folderInput.click());
            
            folderInput.addEventListener('change', () => {
                updateFolderStats(folderInput.files);
            });
            
            // Drag and drop for folders
            folderDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                folderDropZone.classList.add('dragover');
            });
            
            folderDropZone.addEventListener('dragleave', () => {
                folderDropZone.classList.remove('dragover');
            });
            
            folderDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                folderDropZone.classList.remove('dragover');
                // Note: Folder drag and drop is not fully supported in all browsers
                // This is a simplified implementation
                updateFolderStats(e.dataTransfer.files);
            });
            
            // Update file list display
            function updateFileList(files) {
                fileList.innerHTML = '';
                if (files.length > 0) {
                    const ul = document.createElement('ul');
                    ul.className = 'list-disc pl-5';
                    
                    for (let i = 0; i < files.length; i++) {
                        const li = document.createElement('li');
                        li.textContent = `${files[i].name} (${formatFileSize(files[i].size)})`;
                        ul.appendChild(li);
                    }
                    
                    fileList.appendChild(ul);
                }
            }
            
            // Update folder stats display
            function updateFolderStats(files) {
                folderStats.innerHTML = '';
                if (files.length > 0) {
                    const fileTypes = {};
                    let totalSize = 0;
                    
                    for (let i = 0; i < files.length; i++) {
                        totalSize += files[i].size;
                        const ext = files[i].name.split('.').pop().toLowerCase();
                        fileTypes[ext] = (fileTypes[ext] || 0) + 1;
                    }
                    
                    folderStats.innerHTML = `<p>${files.length} files (${formatFileSize(totalSize)})</p>`;
                    
                    const ul = document.createElement('ul');
                    ul.className = 'list-disc pl-5';
                    
                    for (const [ext, count] of Object.entries(fileTypes)) {
                        const li = document.createElement('li');
                        li.textContent = `${ext}: ${count} files`;
                        ul.appendChild(li);
                    }
                    
                    folderStats.appendChild(ul);
                }
            }
            
            // Format file size
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            // Submit form
            submitButton.addEventListener('click', async () => {
                const prompt = document.getElementById('prompt').value.trim();
                if (!prompt) {
                    showStatus('Please enter a prompt', 'error');
                    return;
                }
                
                const outputFormat = document.getElementById('outputFormat').value;
                const processingMode = document.getElementById('processingMode').value;
                const saveOutput = document.getElementById('saveOutput').checked;
                const outputDestination = document.getElementById('outputDestination').value;
                const asyncProcessing = document.getElementById('asyncProcessing').checked;
                const templateFile = templateSelect.value ? { name: templateSelect.value } : null;
                
                // Show progress and status
                progressContainer.classList.remove('hidden');
                statusMessage.classList.remove('hidden');
                showStatus('Processing request...', 'info');
                updateProgress(5);
                
                // Determine if we're processing files or a folder
                if (folderInput.files.length > 0) {
                    // Process folder
                    await processFolder({
                        prompt,
                        templateFile,
                        outputFormat,
                        processingMode,
                        saveOutput,
                        outputDestination,
                        async: asyncProcessing,
                        files: folderInput.files
                    });
                } else if (fileInput.files.length > 0) {
                    // Process individual files
                    await processFiles({
                        prompt,
                        templateFile,
                        outputFormat,
                        processingMode,
                        saveOutput,
                        outputDestination,
                        files: fileInput.files
                    });
                } else {
                    // Process text-only prompt
                    await processPrompt({
                        prompt,
                        templateFile,
                        outputFormat
                    });
                }
            });
            
            // Process folder
            async function processFolder(data) {
                try {
                    // Create FormData
                    const formData = new FormData();
                    formData.append('prompt', data.prompt);
                    
                    if (data.templateFile) {
                        formData.append('templateFile', data.templateFile);
                    }
                    
                    formData.append('outputFormat', data.outputFormat);
                    formData.append('processingMode', data.processingMode);
                    formData.append('saveOutput', data.saveOutput);
                    formData.append('outputDestination', data.outputDestination);
                    formData.append('async', data.async);
                    
                    // Add all files with their relative paths
                    for (let i = 0; i < data.files.length; i++) {
                        const file = data.files[i];
                        formData.append('files', file, file.webkitRelativePath || file.name);
                    }
                    
                    updateProgress(10);
                    showStatus('Uploading folder...', 'info');
                    
                    // Send request
                    const response = await fetch('/api/ask-gemini/folder', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        if (data.async && result.jobId) {
                            // Handle async job
                            showStatus(`Job queued with ID: ${result.jobId}. Waiting for results...`, 'info');
                            
                            // Set up socket listeners for this job
                            const jobId = result.jobId;
                            
                            socket.on(`job-progress-${jobId}`, (data) => {
                                updateProgress(data.progress);
                                showStatus(`Processing job ${jobId}: ${data.progress}% complete`, 'info');
                            });
                            
                            socket.on(`job-completed-${jobId}`, (data) => {
                                updateProgress(100);
                                showStatus(`Job ${jobId} completed successfully!`, 'success');
                                displayResponse(data.result);
                            });
                            
                            socket.on(`job-failed-${jobId}`, (data) => {
                                showStatus(`Job ${jobId} failed: ${data.error}`, 'error');
                            });
                            
                            // Poll for job status as a fallback
                            pollJobStatus(jobId);
                        } else {
                            // Handle synchronous result
                            updateProgress(100);
                            showStatus('Processing completed successfully!', 'success');
                            displayResponse(result);
                        }
                    } else {
                        showStatus(`Error: ${result.response || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    console.error('Error processing folder:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                }
            }
            
            // Poll job status
            async function pollJobStatus(jobId) {
                try {
                    const response = await fetch(`/api/job/${jobId}`);
                    const status = await response.json();
                    
                    if (status.status === 'completed') {
                        updateProgress(100);
                        showStatus(`Job ${jobId} completed successfully!`, 'success');
                        displayResponse(status.result);
                        return;
                    } else if (status.status === 'failed') {
                        showStatus(`Job ${jobId} failed: ${status.error}`, 'error');
                        return;
                    }
                    
                    // Update progress
                    if (status.progress) {
                        updateProgress(status.progress);
                        showStatus(`Processing job ${jobId}: ${status.progress}% complete`, 'info');
                    }
                    
                    // Poll again after 2 seconds
                    setTimeout(() => pollJobStatus(jobId), 2000);
                } catch (error) {
                    console.error('Error polling job status:', error);
                    // Try again after 5 seconds
                    setTimeout(() => pollJobStatus(jobId), 5000);
                }
            }
            
            // Process individual files
            async function processFiles(data) {
                try {
                    // Create FormData
                    const formData = new FormData();
                    formData.append('prompt', data.prompt);
                    
                    if (data.templateFile) {
                        formData.append('templateFile', data.templateFile);
                    }
                    
                    formData.append('outputFormat', data.outputFormat);
                    formData.append('processingMode', data.processingMode);
                    formData.append('saveOutput', data.saveOutput);
                    formData.append('outputDestination', data.outputDestination);
                    
                    // Add all files
                    for (let i = 0; i < data.files.length; i++) {
                        formData.append('files', data.files[i]);
                    }
                    
                    updateProgress(20);
                    showStatus('Uploading files...', 'info');
                    
                    // Send request
                    const response = await fetch('/api/ask-gemini', {
                        method: 'POST',
                        body: formData
                    });
                    
                    updateProgress(80);
                    showStatus('Processing files...', 'info');
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        updateProgress(100);
                        showStatus('Processing completed successfully!', 'success');
                        displayResponse(result);
                    } else {
                        showStatus(`Error: ${result.response || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    console.error('Error processing files:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                }
            }
            
            // Process text-only prompt
            async function processPrompt(data) {
                try {
                    updateProgress(20);
                    showStatus('Sending prompt...', 'info');
                    
                    // Create request body
                    const requestBody = {
                        prompt: data.prompt,
                        outputFormat: data.outputFormat
                    };
                    
                    if (data.templateFile) {
                        requestBody.templateFile = data.templateFile;
                    }
                    
                    // Send request
                    const response = await fetch('/api/ask-gemini', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    updateProgress(80);
                    showStatus('Processing prompt...', 'info');
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        updateProgress(100);
                        showStatus('Processing completed successfully!', 'success');
                        displayResponse(result);
                    } else {
                        showStatus(`Error: ${result.response || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    console.error('Error processing prompt:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                }
            }
            
            // Update progress bar
            function updateProgress(percent) {
                progressBar.style.width = `${percent}%`;
                progressText.textContent = `${percent}%`;
            }
            
            // Show status message
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = 'mb-4 p-3 rounded-md';
                
                switch (type) {
                    case 'error':
                        statusMessage.classList.add('bg-red-100', 'text-red-700');
                        break;
                    case 'success':
                        statusMessage.classList.add('bg-green-100', 'text-green-700');
                        break;
                    case 'info':
                    default:
                        statusMessage.classList.add('bg-blue-100', 'text-blue-700');
                        break;
                }
            }
            
            // Display response
            function displayResponse(result) {
                if (result.responses && Array.isArray(result.responses)) {
                    // Multiple responses
                    let output = '';
                    
                    result.responses.forEach((response, index) => {
                        if (index > 0) output += '\n\n---\n\n';
                        
                        if (response.file) {
                            output += `File: ${response.file}\n\n`;
                        }
                        
                        output += response.response;
                    });
                    
                    responseOutput.textContent = output;
                } else if (result.combined && result.response) {
                    // Combined response
                    responseOutput.textContent = result.response;
                } else if (result.responses) {
                    // Folder structure responses
                    let output = '';
                    
                    for (const [folderPath, responses] of Object.entries(result.responses)) {
                        output += `Folder: ${folderPath}\n\n`;
                        
                        responses.forEach((response, index) => {
                            if (index > 0) output += '\n---\n';
                            
                            if (response.file) {
                                output += `File: ${response.file}\n\n`;
                            }
                            
                            output += response.response + '\n';
                        });
                        
                        output += '\n\n';
                    }
                    
                    responseOutput.textContent = output;
                } else {
                    // Single response
                    responseOutput.textContent = JSON.stringify(result, null, 2);
                }
            }
            
            // Copy to clipboard
            copyButton.addEventListener('click', () => {
                navigator.clipboard.writeText(responseOutput.textContent)
                    .then(() => {
                        const originalText = copyButton.textContent;
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => {
                            copyButton.textContent = originalText;
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy text:', err);
                    });
            });
            
            // Download result
            downloadButton.addEventListener('click', () => {
                const outputFormat = document.getElementById('outputFormat').value;
                let extension, mimeType;
                
                switch (outputFormat) {
                    case 'json':
                        extension = 'json';
                        mimeType = 'application/json';
                        break;
                    case 'html':
                        extension = 'html';
                        mimeType = 'text/html';
                        break;
                    case 'markdown':
                        extension = 'md';
                        mimeType = 'text/markdown';
                        break;
                    case 'text':
                    default:
                        extension = 'txt';
                        mimeType = 'text/plain';
                        break;
                }
                
                const blob = new Blob([responseOutput.textContent], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rapid-ai-response.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // Push to GitHub
            const pushButton = document.getElementById('pushButton');
            pushButton.addEventListener('click', async () => {
                try {
                    showStatus('Pushing changes to GitHub...', 'info');
                    
                    const response = await fetch('/api/github/push', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ message: 'Update from Rapid AI Assistant' })
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        showStatus(`Successfully pushed to GitHub: ${result.message}`, 'success');
                    } else {
                        showStatus(`Error pushing to GitHub: ${result.error}`, 'error');
                    }
                } catch (error) {
                    console.error('Error pushing to GitHub:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                }
            });
        });
    </script>
</body>
</html>